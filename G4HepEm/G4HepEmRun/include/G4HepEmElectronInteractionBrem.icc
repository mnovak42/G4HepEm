
#include "G4HepEmElectronInteractionBrem.hh"

#include "G4HepEmTLData.hh"
#include "G4HepEmElectronData.hh"

#include "G4HepEmElectronTrack.hh"
#include "G4HepEmGammaTrack.hh"
#include "G4HepEmConstants.hh"
#include "G4HepEmRunUtils.hh"

#include "G4HepEmMath.hh"

#include <cmath>
//#include <iostream>


// Bremsstrahlung interaction based on:
// 1. SB: - the numerical Seltzer-Berger DCS for the emitted photon energy.
//        - used between 1 keV - 1 GeV primary e-/e+ kinetic energies.
//        NOTE: the core part i.e. sampling the emitted photon energy is different than
//          that in the G4SeltzerBergerModel. I implemented here my rejection free,
//          memory effcicient (tables only per Z and not per mat-cuts) sampling.
//          Rejection is used only to account dielectric supression and e+ correction.
// 2. RB: - the Bethe-Heitler DCS with modifications such as screening and Coulomb
//          corrections, emission in the field of the atomic electrons and LPM suppression.
//          Used between 1 GeV - 100 TeV primary e-/e+ kinetic energies.
void G4HepEmElectronInteractionBrem::Perform(G4HepEmTLData* tlData, struct G4HepEmData* hepEmData,
                                             bool iselectron, bool isSBmodel) {
  //
  G4HepEmElectronTrack* thePrimaryElTrack = tlData->GetPrimaryElectronTrack();
  G4HepEmTrack* thePrimaryTrack = thePrimaryElTrack->GetTrack();
  //
  double              thePrimEkin = thePrimaryTrack->GetEKin();
  const double        theLogEkin  = thePrimaryTrack->GetLogEKin();
  const int             theMCIndx = thePrimaryTrack->GetMCIndex();
  const G4HepEmMCCData& theMCData = hepEmData->fTheMatCutData->fMatCutData[theMCIndx];
  const double          theGamCut = theMCData.fSecGamProdCutE;
  // return if intercation is not possible (should not happen)
  if (thePrimEkin <= theGamCut) return;
  //
  // == Sampling of the emitted photon energy
  const double eGamma = isSBmodel
                        ? SampleETransferSB(hepEmData, thePrimEkin, theLogEkin, theMCIndx, tlData->GetRNGEngine(), iselectron)
                        : SampleETransferRB(hepEmData, thePrimEkin, theLogEkin, theMCIndx, tlData->GetRNGEngine(), iselectron);
  // get a secondary photon track and sample directions (all will be already in lab. frame)
  G4HepEmTrack* theSecTrack = tlData->AddSecondaryGammaTrack()->GetTrack();
  double*    theSecGammaDir = theSecTrack->GetDirection();
  double*    thePrimElecDir = thePrimaryTrack->GetDirection();
  //
  // == Sampling of the emitted photon and post interaction e-/e+ directions
  SampleDirections(thePrimEkin, eGamma, theSecGammaDir, thePrimElecDir, tlData->GetRNGEngine());
  //
  // == Update primary and set secondary gamma track properties
  //    note: the directions are already set in SampleDirections
  thePrimaryTrack->SetEKin(thePrimEkin - eGamma);
  theSecTrack->SetEKin(eGamma);
  theSecTrack->SetParentID(thePrimaryTrack->GetID());
  // NOTE: the following usually set to very high energy so I don't include this.
  // if secondary gamma energy is higher than threshold(very high by default)
  // then stop tracking the primary particle and create new secondary e-/e+
  // instead of the primary
}

// should be called only for mat-cuts with more than one elements in their material
int G4HepEmElectronInteractionBrem::SelectTargetAtom(const struct G4HepEmElectronData* elData, const int imc,
                                                     const double ekin, const double lekin, const double urndn,
                                                     const bool isbremSB) {
  // start index for this mat-cut and this model (-1 is no elememnt selector i.e. single element material)
  const int   indxStart = isbremSB
                          ? elData->fElemSelectorBremSBStartIndexPerMatCut[imc]
                          : elData->fElemSelectorBremRBStartIndexPerMatCut[imc];
  const double* theData = isbremSB
                          ? &(elData->fElemSelectorBremSBData[indxStart])
                          : &(elData->fElemSelectorBremRBData[indxStart]);
  const int     numData = theData[0];
  const int     numElem = theData[1];
  const double    logE0 = theData[2];
  const double    invLD = theData[3];
  const double*   xdata = &(theData[4]);
  // make sure that $x \in  [x[0],x[ndata-1]]$
  const double   xv = G4HepEmMax(xdata[0], G4HepEmMin(xdata[numElem*(numData-1)], ekin));
  // compute the lowerindex of the x bin (idx \in [0,N-2] will be guaranted)
  const int idxEkin = G4HepEmMax(0.0, G4HepEmMin((lekin-logE0)*invLD, numData-2.0));
  // the real index position is idxEkin x numElem
  int   indx0 = idxEkin*numElem;
  int   indx1 = indx0+numElem;
  // linear interpolation
  const double   x1 = xdata[indx0++];
  const double   x2 = xdata[indx1++];
  const double   dl = x2-x1;
  const double    b = G4HepEmMax(0., G4HepEmMin(1., (xv - x1)/dl));
  int theElemIndex = 0;
  while (theElemIndex<numElem-1 && urndn > xdata[indx0+theElemIndex]+b*(xdata[indx1+theElemIndex]-xdata[indx0+theElemIndex])) { ++theElemIndex; }
  return theElemIndex;
}

template <typename RandomEngine>
void G4HepEmElectronInteractionBrem::SampleDirections(const double thePrimEkin, const double theSecGammaEkin,
                                                      double* theSecGammaDir, double* thePrimElecDir,
                                                      RandomEngine* rnge) {
  // sample photon direction (modified Tsai sampling):
  const double cost = SampleCostModifiedTsai(thePrimEkin, rnge);
  const double sint = std::sqrt((1.0-cost)*(1.0+cost));
  const double  phi = k2Pi*rnge->flat();
  theSecGammaDir[0] = sint * std::cos(phi);
  theSecGammaDir[1] = sint * std::sin(phi);
  theSecGammaDir[2] = cost;
  // rotate to refernce frame (G4HepEmRunUtils function) to get it in lab. frame
  RotateToReferenceFrame(theSecGammaDir, thePrimElecDir);
  // go for the post-interaction primary electron/positiorn direction in lab. farme
  const double primETot = thePrimEkin + kElectronMassC2;
  const double primPTot = std::sqrt(thePrimEkin * (primETot + kElectronMassC2));
  thePrimElecDir[0] = primPTot * thePrimElecDir[0] - theSecGammaEkin * theSecGammaDir[0];
  thePrimElecDir[1] = primPTot * thePrimElecDir[1] - theSecGammaEkin * theSecGammaDir[1];
  thePrimElecDir[2] = primPTot * thePrimElecDir[2] - theSecGammaEkin * theSecGammaDir[2];
  // normalisation
  const double  norm = 1.0 / std::sqrt(thePrimElecDir[0] * thePrimElecDir[0] + thePrimElecDir[1] * thePrimElecDir[1] + thePrimElecDir[2] * thePrimElecDir[2]);
  thePrimElecDir[0] *= norm;
  thePrimElecDir[1] *= norm;
  thePrimElecDir[2] *= norm;
}


// find lower bin index of value: used in acse of CDF values i.e. val in [0,1)
// while vector elements in [0,1]
// note: every 3rd value of the vect contains the kappa-cumulutaive values
int G4HepEmElectronInteractionBrem::LinSearch(const double* vect, const int size, const double val) {
  int i = 0;
  const int size3 = 3*size;
  while (i + 9 < size3) {
    if (vect [i + 0] > val) return i + 0;
    if (vect [i + 3] > val) return i + 3;
    if (vect [i + 6] > val) return i + 6;
    if (vect [i + 9] > val) return i + 9;
    i += 12;
  }
  while (i < size3) {
    if (vect [i] > val)
      break;
    i += 3;
  }
  return i;
}
