
#include "G4HepEmElectronManager.hh"

#include "G4HepEmTLData.hh"
#include "G4HepEmElectronData.hh"
#include "G4HepEmMath.hh"
#include "G4HepEmMSCTrackData.hh"
#include "G4HepEmGammaTrack.hh"
#include "G4HepEmElectronInteractionIoni.hh"
#include "G4HepEmElectronInteractionBrem.hh"
#include "G4HepEmPositronInteractionAnnihilation.hh"

// tlData GetPrimaryElectronTrack needs to be set needs to be set based on the G4Track;

//#define NOMSC


// Note: pStepLength will be set here i.e. this is the first access to it that
//       will clear the previous step value.
void G4HepEmElectronManager::HowFar(struct G4HepEmData* hepEmData, struct G4HepEmParameters* hepEmPars, G4HepEmTLData* tlData) {
  G4HepEmElectronTrack* theElTrack = tlData->GetPrimaryElectronTrack();
  G4HepEmTrack* theTrack = theElTrack->GetTrack();
  // Sample the `number-of-interaction-left`
  for (int ip=0; ip<3; ++ip) {
    if (theTrack->GetNumIALeft(ip)<=0.) {
      theTrack->SetNumIALeft(-G4HepEmLog(tlData->GetRNGEngine()->flat()), ip);
    }
  }
  HowFar(hepEmData, hepEmPars, theElTrack, tlData->GetRNGEngine());
}

bool G4HepEmElectronManager::CheckDelta(struct G4HepEmData* hepEmData, G4HepEmTrack* theTrack, double rand) {
  const bool isElectron = (theTrack->GetCharge() < 0.0);
  const G4HepEmElectronData* elData = isElectron
                                      ? hepEmData->fTheElectronData
                                      : hepEmData->fThePositronData;
  const int iDProc      = theTrack->GetWinnerProcessIndex();
  const int theIMC      = theTrack->GetMCIndex();
  const int theMatIndex = hepEmData->fTheMatCutData->fMatCutData[theIMC].fHepEmMatIndex;
  const double theEkin  = theTrack->GetEKin();
  const double theLEkin = theTrack->GetLogEKin();
  const double mxsec = (iDProc<2)
                      ? GetRestMacXSec(elData, theIMC, theEkin, theLEkin, iDProc==0)
                      : ComputeMacXsecAnnihilation(theEkin, hepEmData->fTheMaterialData->fMaterialData[theMatIndex].fElectronDensity);
  return mxsec <= 0.0 || rand > mxsec*theTrack->GetMFP(iDProc);
}


void G4HepEmElectronManager::Perform(struct G4HepEmData* hepEmData, struct G4HepEmParameters* hepEmPars, G4HepEmTLData* tlData) {
  G4HepEmElectronTrack* theElTrack = tlData->GetPrimaryElectronTrack();
  G4HepEmTrack*   theTrack = theElTrack->GetTrack();
  // Set default values to cover all early returns due to protection against
  // zero step lengths, conversion errors, etc.
  theTrack->SetEnergyDeposit(0);
  theElTrack->SetPStepLength(theTrack->GetGStepLength());
  const bool isElectron = (theTrack->GetCharge() < 0.0);

  if (theTrack->GetGStepLength()<=0.) return;

  bool stopped = PerformContinuous(hepEmData, hepEmPars, theElTrack, tlData->GetRNGEngine());
  if (stopped) {
    // call annihilation for e+ !!!
    if (!isElectron) {
      G4HepEmPositronInteractionAnnihilation::Perform(tlData, true);
    }
    return;
  }

  // === 4. Discrete part of the interaction (if any)
  // 4/1. check if discrete process limited the step return otherwise (i.e. if
  //      continous or boundary process limited the step)
  const int iDProc = theTrack->GetWinnerProcessIndex();
  if (iDProc < 0 || theTrack->GetOnBoundary()) {
    return;
  }
  // reset number of interaction left for the winner discrete process
  theTrack->SetNumIALeft(-1.0, iDProc);

  // 4/2. check if delta interaction happens instead of the real discrete process
  if (CheckDelta(hepEmData, theTrack, tlData->GetRNGEngine()->flat())) {
    return;
  }

  // 4/3. perform the discrete part of the winner interaction
  const double theEkin = theTrack->GetEKin();
  switch (iDProc) {
    case 0: // invoke ioni (for e-/e+):
            G4HepEmElectronInteractionIoni::Perform(tlData, hepEmData, isElectron);
            break;
    case 1: // invoke brem (for e-/e+): either SB- or Rel-Brem
            G4HepEmElectronInteractionBrem::Perform(tlData, hepEmData, isElectron, theEkin < hepEmPars->fElectronBremModelLim);
            break;
    case 2: // invoke annihilation (in-flight) for e+
            G4HepEmPositronInteractionAnnihilation::Perform(tlData, false);
            break;
  }
}


double  G4HepEmElectronManager::GetRestRange(const struct G4HepEmElectronData* elData, const int imc, const double ekin, const double lekin) {
  const int numELossData = elData->fELossEnergyGridSize;
  const int iRangeStarts = 5*numELossData*imc;
  // use the G4HepEmRunUtils function for interpolation
  const double     range = GetSplineLog(numELossData, elData->fELossEnergyGrid, &(elData->fELossData[iRangeStarts]), ekin, lekin, elData->fELossLogMinEkin, elData->fELossEILDelta);
  return G4HepEmMax(0.0, range);
}


double  G4HepEmElectronManager::GetRestDEDX(const struct G4HepEmElectronData* elData, const int imc, const double ekin, const double lekin) {
  const int numELossData = elData->fELossEnergyGridSize;
  const int  iDEDXStarts = numELossData*(5*imc + 2); // 5*imc*numELossData is where range-start + 2*numELossData
  // use the G4HepEmRunUtils function for interpolation
  const double      dedx = GetSplineLog(numELossData, elData->fELossEnergyGrid, &(elData->fELossData[iDEDXStarts]), ekin, lekin, elData->fELossLogMinEkin, elData->fELossEILDelta);
  return G4HepEmMax(0.0, dedx);
}


double  G4HepEmElectronManager::GetInvRange(const struct G4HepEmElectronData* elData, int imc, double range) {
  const int numELossData = elData->fELossEnergyGridSize;
  const int iRangeStarts = 5*numELossData*imc;
  // low-energy approximation
  const double minRange = elData->fELossData[iRangeStarts];
  if (range<minRange) {
    const double dum = range/minRange;
    return G4HepEmMax(0.0, elData->fELossEnergyGrid[0]*dum*dum);
  }
  // use the G4HepEmRunUtils function for finding the range bin index and for interpolation
  // find `i`, lower index of the range such that R_{i} <= r < R_{i+1}
  const int     iRlow = FindLowerBinIndex(&(elData->fELossData[iRangeStarts]), numELossData, range, 2);
  // interpolate: x,y and sd
  const double energy = GetSpline(&(elData->fELossData[iRangeStarts]), elData->fELossEnergyGrid, &(elData->fELossData[iRangeStarts+4*numELossData]), range, iRlow, 2);
  return G4HepEmMax(0.0, energy);
}


double  G4HepEmElectronManager::GetRestMacXSec(const struct G4HepEmElectronData* elData, const int imc, const double ekin, const double lekin, bool isioni) {
  const int iIoniStarts = elData->fResMacXSecStartIndexPerMatCut[imc];
  const int numIoniData = elData->fResMacXSecData[iIoniStarts]; // x3 for the 3 values and +5 at the beginning
  const int      iStart = (isioni) ? iIoniStarts : iIoniStarts + 3*numIoniData + 5;
  const int     numData = elData->fResMacXSecData[iStart];
  const double  minEKin = elData->fResMacXSecData[iStart+5];
  if (ekin<minEKin) {return 0.0; }
  // use the G4HepEmRunUtils function for interpolation
  const double    mxsec = GetSplineLog(numData, &(elData->fResMacXSecData[iStart+5]), ekin, lekin, elData->fResMacXSecData[iStart+3],elData->fResMacXSecData[iStart+4]);
  return G4HepEmMax(0.0, mxsec);
}


double  G4HepEmElectronManager::GetRestMacXSecForStepping(const struct G4HepEmElectronData* elData, const int imc, double ekin, double lekin, bool isioni) {
  constexpr double log08 = -0.22314355131420971;
  const int  iIoniStarts = elData->fResMacXSecStartIndexPerMatCut[imc];
  const int  numIoniData = elData->fResMacXSecData[iIoniStarts]; // x3 for the 3 values and +5 at the beginning
  const int       iStart = (isioni) ? iIoniStarts : iIoniStarts + 3*numIoniData + 5;
  const int      numData = elData->fResMacXSecData[iStart];
  const double mxsecMinE = elData->fResMacXSecData[iStart+5];
  const double mxsecMaxE = elData->fResMacXSecData[iStart+1];
  const double mxsecMaxV = elData->fResMacXSecData[iStart+2];
  if (ekin > mxsecMaxE) {
    // compute reduced energy: we assume that 1/lambda is higher at lower energy so we provide an overestimate
    const double ekinReduced = 0.8 * ekin;
    if (ekinReduced < mxsecMaxE) {
      return G4HepEmMax(0.0, mxsecMaxV);
    } else {
      // otherwise we are still on the right side of the maximum so provide 1/lambda at this reduced energy
      ekin   = ekinReduced;
      lekin += log08;
    }
  }
  if (ekin<mxsecMinE) {return 0.0; }
  // use the G4HepEmRunUtils function for interpolation
  const double mxsec = GetSplineLog(numData, &(elData->fResMacXSecData[iStart+5]), ekin, lekin, elData->fResMacXSecData[iStart+3], elData->fResMacXSecData[iStart+4]);
  return G4HepEmMax(0.0, mxsec);
}


double  G4HepEmElectronManager::GetTransportMFP(const struct G4HepEmElectronData* elData, const int im, const double ekin, const double lekin) {
  const int numEkin = elData->fELossEnergyGridSize;
  const int iStarts = 2*numEkin*im;
  // use the G4HepEmRunUtils function for interpolation
  const double tr1mxsec = G4HepEmMax(0.0, GetSplineLog(numEkin, elData->fELossEnergyGrid, &(elData->fTr1MacXSecData[iStarts]), ekin, lekin, elData->fELossLogMinEkin, elData->fELossEILDelta));
  return tr1mxsec > 0. ? 1./tr1mxsec : kALargeValue;
}


double G4HepEmElectronManager::ComputeMacXsecAnnihilation(const double ekin, const double electronDensity) {
  // Heitler model for e+e- -> 2g annihilation
  const double tau   = ekin*kInvElectronMassC2;
  const double gam   = tau + 1.0;
  const double gam2  = gam*gam;
  const double bg2   = tau * (tau+2.0);
  const double bg    = std::sqrt(bg2);
  return electronDensity*kPir02*((gam2+4.*gam+1.)*G4HepEmLog(gam+bg) - (gam+3.)*bg) / (bg2*(gam+1.));
}


double G4HepEmElectronManager::ComputeMacXsecAnnihilationForStepping(const double ekin, const double electronDensity) {
  // compute mxsec for the reduced energy (assuming that the mac-xsec decreasing with ekin)
  return ComputeMacXsecAnnihilation(0.8*ekin, electronDensity);
}


void G4HepEmElectronManager::ConvertTrueToGeometricLength(const G4HepEmData* hepEmData, G4HepEmMSCTrackData* mscData,
                                                         double ekin, double range, int imc, bool iselectron) {
  mscData->fPar1 = -1.;
  mscData->fPar2 =  0.;
  mscData->fPar3 =  0.;
  // NOTE: in theory, the continuous e-loss limits the step length such its at most the range.
  //       So this line below should never have any effects! Since this is the only part that
  //       might limits the true step length in the true --> geom conversion, we might drop this
  //       that makes possible the decision if MSC limited the step even before this conversion.
  mscData->fTrueStepLength = G4HepEmMin(mscData->fTrueStepLength, range);
  //  do the true -> geom transformation
  mscData->fZPathLength = mscData->fTrueStepLength;
  // z = t for very small true-path-length
  const double kTlimitMinfix2 = 1.0E-6; // 1 [nm]
  if (mscData->fTrueStepLength < kTlimitMinfix2) {
    return;
  }
  //
  const double kTauSmall  = 1.0e-16;
  const double kDtrl      = 0.05;
  const double tau        = mscData->fTrueStepLength / mscData->fLambtr1;
  if (tau < kTauSmall) {
    mscData->fZPathLength = G4HepEmMin(mscData->fTrueStepLength, mscData->fLambtr1);
  } else if (mscData->fTrueStepLength < range * kDtrl) {
    const double kTauLim  = 1.0e-6;
    mscData->fZPathLength = (tau < kTauLim)
                            ? mscData->fTrueStepLength * (1. - 0.5 * tau)
                            : mscData->fLambtr1 * (1. - G4HepEmExp(-tau));
  } else if (ekin < kElectronMassC2 || mscData->fTrueStepLength == range) {
    mscData->fPar1        = 1. / range;
    mscData->fPar2        = 1. / (mscData->fPar1 * mscData->fLambtr1);
    mscData->fPar3        = 1. + mscData->fPar2;
    mscData->fZPathLength = 1. / (mscData->fPar1 * mscData->fPar3);
    if (mscData->fTrueStepLength < range) {
      mscData->fZPathLength *= (1. - G4HepEmPow(1. - mscData->fTrueStepLength/range, mscData->fPar3));
    }
  } else {
    const double rfin     = G4HepEmMax(range - mscData->fTrueStepLength, 0.01 * range);
    const G4HepEmElectronData* elData = iselectron ? hepEmData->fTheElectronData : hepEmData->fThePositronData;
    const double t1       = GetInvRange(elData, imc, rfin);
    const int    imat     = (hepEmData->fTheMatCutData->fMatCutData[imc]).fHepEmMatIndex;
    const double lambda1  = GetTransportMFP(elData, imat, t1, G4HepEmLog(t1));
    mscData->fPar1        = (mscData->fLambtr1 - lambda1) / (mscData->fLambtr1 * mscData->fTrueStepLength); // alpha
    mscData->fPar2        = 1. / (mscData->fPar1 * mscData->fLambtr1);
    mscData->fPar3        = 1. + mscData->fPar2;
    mscData->fZPathLength = (1. - G4HepEmPow(lambda1/mscData->fLambtr1, mscData->fPar3))/(mscData->fPar1 * mscData->fPar3);
  }
  mscData->fZPathLength = G4HepEmMin(mscData->fZPathLength, mscData->fLambtr1);
}


void G4HepEmElectronManager::ConvertGeometricToTrueLength(G4HepEmMSCTrackData* mscData, double range, double gStepToConvert) {
  // step was not defined by transportation: i.e. physics so we know everything,
  // i.e. fTrueStepLength is known because the particle went as far as we expected
  // NOTE: this is done directly now in the caller
//  if (!onBoundary) {
//    return;
//  }
//   return;
  // else: convert geom -> true by using the mean value
  // get the geometrical step length
  mscData->fZPathLength = gStepToConvert;
  // t = z for very small step
  const double kTLimitMinfix2 = 1.0E-6; // 1 [nm]
  if (gStepToConvert < kTLimitMinfix2) {
    mscData->fTrueStepLength = gStepToConvert;
  } else {
    // recalculation
    const double kTauSmall = 1.0e-16;
    double tlength = gStepToConvert;
    if (gStepToConvert > mscData->fLambtr1 * kTauSmall) {
      if (mscData->fPar1 < 0.) {
        tlength = -mscData->fLambtr1 * G4HepEmLog(1. - gStepToConvert / mscData->fLambtr1);
      } else {
        const double dum = mscData->fPar1 * mscData->fPar3 * gStepToConvert;
        if (dum < 1.) {
          tlength = (1. - G4HepEmPow(1.-dum, 1./mscData->fPar3)) / mscData->fPar1;
        } else {
          tlength = range;
        }
      }
      if (tlength < gStepToConvert) {
        tlength = gStepToConvert;
      }
    }
    // we make sure in the caller that the results of g->t conversion is not longer
    // than the original true step length
    mscData->fTrueStepLength = tlength;
  }
}
