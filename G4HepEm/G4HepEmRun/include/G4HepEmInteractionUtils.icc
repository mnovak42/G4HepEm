#include "G4HepEmInteractionUtils.hh"

#include <cmath>

// times = 1.0 for Brem and -1.0 for Pair production
// densityCor = 0.0  for Pair production
G4HepEmHostDevice
void EvaluateLPMFunctions(double& funcXiS, double& funcGS, double& funcPhiS, const double egamma,
     const double etotal, const double elpm, const double z23, const double ilVarS1,
     const double ilVarS1Cond, const double densityCor, const double times) {
  const double     sqrt2 = 1.414213562373095;
  const double redegamma = egamma / etotal;
  const double varSprime = std::sqrt( 0.125 * redegamma * elpm / ( times*( 1.0 - redegamma ) * etotal ) );
  const double     varS1 = z23 / ( 184.15 * 184.15 );
  const double condition = sqrt2*varS1;
  double funcXiSprime = 2.0;
  if (varSprime > 1.0) {
    funcXiSprime = 1.0;
  } else if (varSprime > condition) {
    const double funcHSprime = G4HepEmLog(varSprime)*ilVarS1Cond;
    funcXiSprime = 1.0 + funcHSprime - 0.08*(1.0-funcHSprime)*funcHSprime*(2.0-funcHSprime)*ilVarS1Cond;
  }
  funcXiS = funcXiSprime;
  const double    varS = varSprime / std::sqrt( funcXiSprime );
  // - include dielectric suppression effect into s according to Migdal (only in case of Brem !)
  double varShat = varS;
  if (densityCor != 0.0) {
    varShat *= ( 1.0 + densityCor / (egamma*egamma) );
    funcXiS = 2.0;
    if (varShat > 1.0) {
      funcXiS = 1.0;
    } else if (varShat > varS1) {
      funcXiS = 1.0 + G4HepEmLog ( varShat ) * ilVarS1;
    }
  }
  // avluate the LPM G(s) and Phi(s) function (approximations) at s = s-hat
  const double lpmSLimit =  2.0;
  const double lpmISDelt = 20.0;
  if (varShat < lpmSLimit) {
    double  val = varShat*lpmISDelt;
    int    ilow = (int)val;
    val        -= ilow;
    ilow       *= 2;
    funcGS      = ( kFuncLPM[ilow+2] - kFuncLPM[ilow]   ) * val + kFuncLPM[ilow];
    funcPhiS    = ( kFuncLPM[ilow+3] - kFuncLPM[ilow+1] ) * val + kFuncLPM[ilow+1];
  } else {
    double ss = 1.0/(varShat*varShat);
    ss *= ss;
    funcGS   = 1.0-0.0230655*ss;
    funcPhiS = 1.0-0.01190476*ss;
  }
  //MAKE SURE SUPPRESSION IS SMALLER THAN 1: due to Migdal's approximation on xi
  if (funcXiS*funcPhiS > 1.0 || varShat > 0.57) {
    funcXiS = 1.0/funcPhiS;
  }
}
