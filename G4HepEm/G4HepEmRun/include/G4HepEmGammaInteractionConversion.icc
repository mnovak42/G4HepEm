#include "G4HepEmGammaInteractionConversion.hh"

#include "G4HepEmTLData.hh"
#include "G4HepEmGammaData.hh"
#include "G4HepEmConstants.hh"
#include "G4HepEmMath.hh"

#include <iostream>

void G4HepEmGammaInteractionConversion::Perform(G4HepEmTLData* tlData, struct G4HepEmData* hepEmData) {
  G4HepEmTrack* thePrimaryTrack = tlData->GetPrimaryGammaTrack()->GetTrack();
  const double       thePrimGmE = thePrimaryTrack->GetEKin();
  //
  // check kinematical limit: gamma energy(Eg) must be at least 2 e- rest mass
  // (but the model should be used at higher energies above 100 MeV)
  if (thePrimGmE < 2.*kElectronMassC2) {
    return;
  }
  //
  // Sample/compute kinetic energies of the e- and e+ pair
  const double theLogPrimGmE = thePrimaryTrack->GetLogEKin();
  const int        theMCIndx = thePrimaryTrack->GetMCIndex();
  double elKinEnergy;  // e- kinetic energy
  double posKinEnergy; // e+ kinetic energy
  SampleKinEnergies(hepEmData, thePrimGmE, theLogPrimGmE, theMCIndx, elKinEnergy, posKinEnergy, tlData->GetRNGEngine());
  //
  // Sample/compute secondary e-/e+ directions:
  // obtain 2 secondary electorn track (one with +1.0 charge for e+)
  G4HepEmTrack* theSecElTrack  = tlData->AddSecondaryElectronTrack()->GetTrack();
  G4HepEmTrack* theSecPosTrack = tlData->AddSecondaryElectronTrack()->GetTrack();
  SampleDirections(thePrimaryTrack->GetDirection(), theSecElTrack->GetDirection(), theSecPosTrack->GetDirection(),
                   elKinEnergy, posKinEnergy, tlData->GetRNGEngine());
  //
  // Set remaining properties of the secondary tracks
  theSecElTrack->SetEKin(elKinEnergy);
  theSecElTrack->SetParentID(thePrimaryTrack->GetID());
  theSecPosTrack->SetEKin(posKinEnergy);
  theSecPosTrack->SetParentID(thePrimaryTrack->GetID());
  theSecPosTrack->SetCharge(+1.0);

  //
  // Kill the primary gamma track by setting its energy to zero.
  thePrimaryTrack->SetEKin(0.0);
}

// should be called only for mat-cuts with more than one elements in their material
int G4HepEmGammaInteractionConversion::SelectTargetAtom(const struct G4HepEmGammaData* gmData, const int imat,
                                                        const double ekin, const double lekin, const double urndn) {
  // start index for this material
  const int   indxStart = gmData->fElemSelectorConvStartIndexPerMat[imat];
  const double* theData = &(gmData->fElemSelectorConvData[indxStart]);
  const int     numData = gmData->fElemSelectorConvEgridSize;
  const int     numElem = theData[0]; // the very first element for each material
  const double    logE0 = gmData->fElemSelectorConvLogMinEkin;
  const double    invLD = gmData->fElemSelectorConvEILDelta;
  const double*   xdata = gmData->fElemSelectorConvEgrid;
  // make sure that $x \in  [x[0],x[ndata-1]]$
  const double   xv = G4HepEmMax(xdata[0], G4HepEmMin(xdata[numData-1], ekin));
  // compute the lowerindex of the x bin (idx \in [0,N-2] will be guaranted)
  const int idxEkin = G4HepEmMax(0.0, G4HepEmMin((lekin-logE0)*invLD, numData-2.0));
  // linear interpolation
  const double   x1 = xdata[idxEkin];
  const double   x2 = xdata[idxEkin+1];
  const double   dl = x2-x1;
  const double    b = G4HepEmMax(0., G4HepEmMin(1., (xv - x1)/dl));
  // the real index position of the y-data: idxEkin x (numElem-1)+1 (+1 the very first #element)
  const int  indx0 = idxEkin*(numElem-1) + 1;
  const int  indx1 = indx0 + (numElem-1);
  int theElemIndex = 0;
  while (theElemIndex<numElem-1 && urndn > theData[indx0+theElemIndex]+b*(theData[indx1+theElemIndex]-theData[indx0+theElemIndex])) { ++theElemIndex; }
  return theElemIndex;
}

void G4HepEmGammaInteractionConversion::ComputePhi12(const double delta, double &phi1, double &phi2) {
   if (delta > 1.4) {
     phi1 = 21.0190 - 4.145*G4HepEmLog(delta + 0.958);
     phi2 = phi1;
   } else {
     phi1 = 20.806 - delta*(3.190 - 0.5710*delta);
     phi2 = 20.234 - delta*(2.126 - 0.0903*delta);
   }
}


// Compute the value of the screening function 3*PHI1(delta) - PHI2(delta):
double G4HepEmGammaInteractionConversion::ScreenFunction1(const double delta) {
 return (delta > 1.4) ? 42.038 - 8.29*G4HepEmLog(delta + 0.958)
                      : 42.184 - delta*(7.444 - 1.623*delta);
}


// Compute the value of the screening function 1.5*PHI1(delta) +0.5*PHI2(delta):
double G4HepEmGammaInteractionConversion::ScreenFunction2(const double delta) {
 return (delta > 1.4) ? 42.038 - 8.29*G4HepEmLog(delta + 0.958)
                      : 41.326 - delta*(5.848 - 0.902*delta);
}


// Same as ScreenFunction1 and ScreenFunction2 but computes them at once
void G4HepEmGammaInteractionConversion::ScreenFunction12(const double delta, double &f1, double &f2) {
 if (delta > 1.4) {
   f1 = 42.038 - 8.29*G4HepEmLog(delta + 0.958);
   f2 = f1;
 } else {
   f1 = 42.184 - delta*(7.444 - 1.623*delta);
   f2 = 41.326 - delta*(5.848 - 0.902*delta);
 }
}
